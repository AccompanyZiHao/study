(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{659:function(n,e,a){"use strict";a.r(e);var t=a(5),l=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。")]),n._v(" "),a("p",[n._v("你应当 保留 两个分区中每个节点的初始相对位置。")]),n._v(" "),a("h2",{attrs:{id:"示例-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-1"}},[n._v("#")]),n._v(" 示例 1：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("输入：head = [1,4,3,2,5,2], x = 3\n输出：[1,2,2,4,3,5]\n")])])]),a("h2",{attrs:{id:"示例-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[n._v("#")]),n._v(" 示例 2：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("输入：head = [2,1], x = 2\n输出：[1,2]\n")])])]),a("h2",{attrs:{id:"提示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提示"}},[n._v("#")]),n._v(" 提示：")]),n._v(" "),a("ul",[a("li",[n._v("链表中节点的数目在范围 [0, 200] 内")]),n._v(" "),a("li",[n._v("-100 <= Node.val <= 100")]),n._v(" "),a("li",[n._v("-200 <= x <= 200")])]),n._v(" "),a("p",[n._v("看到这个题不就是一个排序嘛，类似快速排序的那种，给你一个中间值，比他小的放左边，比它大的放右边，这个题呢只不过是找出比给定的值小的节点放在前面，如果比给定的值大的话则保持原来的相对位置。")]),n._v(" "),a("p",[n._v("思路分析：")]),n._v(" "),a("ol",[a("li",[n._v("判断链表是否为空")]),n._v(" "),a("li",[n._v("定义连个链表 big, small, 分别用来存放比 x 大的和比 x 小的链表")])]),n._v(" "),a("p",[n._v("用实例一来演示")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 初始值 [1 4 3 2 5 2]    x = 3\n// 循环链表\nfor(let cur = head, next; cur; cur = next){\n  // cur 当前的指针， next 下一个指针\n  next = cur.next // next [4 3 2 5 2]\n  // next 指针定义完 断开 cur 这个指针\n  cur.next  = null // cur [1]\n  // 当前值 2 小于 x  3\n  if(cur.val < x){\n    smallNode.next = cur\n    smallNode = cur\n  }else{\n    bigNode.next = cur\n    bigNode = cur\n  }\n}\n\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("初始值\nsamll     [0]\nbig       [0]\n第一轮 1\nsmallNode [1]\nsmall     [0 ,1]\nbig       [0]\n第二轮 4\nbigNode   [4]\nsmall     [0 ,1]\nbig       [0, 4]\n第三轮 3\nbigNode   [3]\nsmall     [0 ,1]\nbig       [0, 4, 3]\n第四轮 2\nsmallNode   [2]\nsmall     [0 ,1, 2]\nbig       [0, 4, 3]\n第五轮 5\nbigNode   [5]\nsmall     [0 ,1, 2]\nbig       [0, 4, 3, 5]\n第六轮 2\nsmallNode   [2]\nsmall     [0 ,1, 2, 2]\nbig       [0, 4, 3, 5]\n")])])]),a("p",[n._v("循环结束的时候，我们把 "),a("code",[n._v("smallNode.next")]),n._v(" 指向 "),a("code",[n._v("big.next")]),n._v(",这个时候 "),a("code",[n._v("samll.next")]),n._v(" 的链表就是我们想要的了即 "),a("code",[n._v("[1,2,2,4,3,5]")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("/*\n * @lc app=leetcode.cn id=86 lang=javascript\n *\n * [86] 分隔链表\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function(head, x) {\n  if(!head) return null\n  // 创建两个链表 一个链表存储比 x 小的元素 一个存储比 x 大的元素\n  let big = new ListNode()\n  let small = new ListNode()\n  // 定义两个指针\n  let bigNode = big\n  let smallNode = small\n  for(let cur = head, next; cur; cur = next){\n    next  = cur.next\n    cur.next = null\n    if(cur.val < x){\n      smallNode.next = cur\n      smallNode = cur\n    }else{\n      bigNode.next = cur\n      bigNode = cur\n    }\n  }\n  smallNode.next = big.next\n  return small.next\n};\n// @lc code=end\n\n")])])])])}),[],!1,null,null,null);e.default=l.exports}}]);