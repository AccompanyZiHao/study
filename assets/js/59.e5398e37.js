(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{670:function(r,n,a){"use strict";a.r(n);var e=a(5),t=Object(e.a)({},(function(){var r=this,n=r.$createElement,a=r._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("p",[r._v("先吐槽一下，这个题指定有毛病，"),a("code",[r._v("test")]),r._v(" 测试的时候，不通过，浪费我不少时间，看了不少别人的解题，寻思着自己的思路没啥问题，咋不行呢，于是 "),a("code",[r._v("submit")]),r._v(" 试一下，结果，一点毛病都没有，哎，生活不易，白菜叹气！这个示例有问题，可以直接跳过示例查看思路。")]),r._v(" "),a("p",[r._v("给你一个整数数组 "),a("code",[r._v("arr")]),r._v(" ，请使用 煎饼翻转 完成对数组的排序。")]),r._v(" "),a("p",[r._v("一次煎饼翻转的执行过程如下：")]),r._v(" "),a("ol",[a("li",[r._v("选择一个整数 k ，1 <= k <= arr.length")]),r._v(" "),a("li",[r._v("反转子数组 arr[0...k-1]（下标从 0 开始）")]),r._v(" "),a("li",[r._v("例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。")])]),r._v(" "),a("p",[r._v("以数组形式返回能使 "),a("code",[r._v("arr")]),r._v(" 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在  10 * "),a("code",[r._v("arr.length")]),r._v(" 范围内的有效答案都将被判断为正确。")]),r._v(" "),a("h2",{attrs:{id:"示例-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-1"}},[r._v("#")]),r._v(" 示例 1：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("输入：[3,2,4,1]\n输出：[4,2,4,3]\n解释：\n我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。\n初始状态 arr = [3, 2, 4, 1]\n第一次翻转后（k = 4）：arr = [1, 4, 2, 3]\n第二次翻转后（k = 2）：arr = [4, 1, 2, 3]\n第三次翻转后（k = 4）：arr = [3, 2, 1, 4]\n第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。\n")])])]),a("h2",{attrs:{id:"示例-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[r._v("#")]),r._v(" 示例 2：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("输入：[1,2,3]\n输出：[]\n解释：\n输入已经排序，因此不需要翻转任何内容。\n请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。\n")])])]),a("h2",{attrs:{id:"提示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提示"}},[r._v("#")]),r._v(" 提示：")]),r._v(" "),a("ul",[a("li",[r._v("1 <= arr.length <= 100")]),r._v(" "),a("li",[r._v("1 <= arr[i] <= arr.length")]),r._v(" "),a("li",[r._v("arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列）\n通过次数 38,953")])]),r._v(" "),a("h2",{attrs:{id:"解题思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[r._v("#")]),r._v(" 解题思路")]),r._v(" "),a("p",[r._v("先理解这个题，意思就是说每次找到最大的值，先把他放在头部，然后反转，放到尾部，k 呢就是这个最大值的下标加 1；\n找到最大的然后找第二大的，继续上面的过程")]),r._v(" "),a("ol",[a("li",[r._v("找到最大值")]),r._v(" "),a("li",[r._v("对称翻转数组, 把最大的放在头部")]),r._v(" "),a("li",[r._v("再次翻转，把最大的放在尾部")]),r._v(" "),a("li",[r._v("删除最后一个")])]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("/*\n * @lc app=leetcode.cn id=969 lang=javascript\n *\n * [969] 煎饼排序\n */\n\n// @lc code=start\n/**\n * @param {number[]} arr\n * @return {number[]}\n */\nvar pancakeSort = function (arr) {\n    // 3,2,4,1\n    let stash = [], maxIndex;\n    while (arr.length > 1) {\n        maxIndex = findMaxIndex(arr)\n        if(maxIndex > 0){\n            stash.push(maxIndex + 1)\n        }\n        reverse(arr, maxIndex)\n        reverse(arr, arr.length -1)\n        stash.push(arr.length)\n        arr.pop()\n    }\n    return stash\n};\n\nfunction reverse(arr, k) {\n    if (k < 1) return\n    let i = 0;\n    let j = k;\n    while (i < j) {\n        [arr[i], arr[j]] = [arr[j], arr[i]]\n        i++\n        j--\n    }\n}\n\nfunction findMaxIndex(arr) {\n    let index = 0\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > arr[index]) {\n            index = i\n        }\n    }\n    return index\n}\n// @lc code=end\n\n")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);